# 25. 問題にタグをつける

## 目的 / 背景

- ユーザーが問題の性質を一目で理解し、適切なプロンプト戦略を立てられるようにする。
- タグ（カテゴリ）により問題を分類し、タグ別のヒントや統計を提供する。
- `docs/app.md` UI/UX改善、プロンプト学習効果の向上。

## 完了条件

- `questions` テーブルに `tags TEXT[]` カラムを追加（マイグレーション実行）。
- `backend/models/question.go` に `Tags []string` フィールド追加。
- `backend/models/tag.go` でタグメタデータ（アイコン、説明、プロンプトヒント）定義。
- `GET /api/v1/questions` で `tags` を含むJSONレスポンス返却。
- フロントエンド: 問題一覧・詳細ページにタグアイコン表示（最低3問にタグ付与）。
- フロントエンド: 問題詳細ページにタグ別プロンプトヒント表示。
- 単体テスト: タグ付き問題のCRUD操作が正常動作。

## スコープ

- 含む: タグデータ構造、タグ表示UI、プロンプトヒント、初期データ投入（3-5タグ）。
- 含まない: タグフィルタリング機能、タグ別統計API、管理画面でのタグ編集。

## 背景

### 現在の課題

1. **問題の性質が分かりにくい**
   - 問題文を読むまで思考プロセスが不明
   - プロンプトの書き方が問題ごとに異なる

2. **プロンプトの工夫がしづらい**
   - 計算問題: 「段階的に計算して」
   - 文字数え: 「一文字ずつ確認して」
   - タイプ別の有効な指示をユーザーが知らない

3. **学習効果の可視化が不十分**
   - 得意/苦手なタイプが分からない
   - プロンプト改善の方向性が見えにくい

## タグ分類

### 提案するタグ体系

| タグ                | 説明                       | プロンプトのコツ                           | 例                   |
| ------------------- | -------------------------- | ------------------------------------------ | -------------------- |
| 🧮 **計算**         | 数値計算が必要             | 「段階的に計算して」「途中式を示して」     | 1+1、123×456         |
| 🔤 **文字数え**     | 文字列内の特定文字を数える | 「一文字ずつ確認して」「リストアップして」 | strawberry の r の数 |
| 📝 **文章問題**     | 文章を読み解いて答える     | 「問題文を整理して」「条件を列挙して」     | 年齢算、速さの問題   |
| 🧩 **論理パズル**   | 論理的思考が必要           | 「仮定を立てて検証して」「場合分けして」   | 数独、ナンプレ       |
| 🎨 **パターン認識** | 規則性を見つける           | 「規則性を探して」「パターンを分析して」   | 数列、図形問題       |
| 🌍 **一般知識**     | 知識ベースの問題           | 「知っている情報を整理して」               | 首都、歴史           |
| 🔢 **推定・概算**   | おおよその値を求める       | 「オーダーを考えて」「概算で」             | フェルミ推定         |
| 🤔 **思考実験**     | 抽象的な思考が必要         | 「多角的に考えて」「前提を確認して」       | トロッコ問題など     |

## 作業手順

### Phase 1: データベーススキーマ拡張 🏗️

#### 1-1. questionsテーブルにタグカラムを追加

```sql
-- db/migrations/20250130_add_question_tags.sql
ALTER TABLE questions
ADD COLUMN tags TEXT[] DEFAULT '{}';

COMMENT ON COLUMN questions.tags IS 'Array of tag identifiers (e.g., {calculation, text_problem})';

-- インデックスを追加（タグによる検索を高速化）
CREATE INDEX idx_questions_tags ON questions USING GIN(tags);
```

**タグの保存形式:**

- PostgreSQLの配列型 `TEXT[]` を使用
- 例: `{'calculation', 'number_counting'}`

#### 1-2. 既存問題へのタグ付与

```sql
-- 初期データにタグを設定
UPDATE questions SET tags = ARRAY['calculation'] WHERE id = 1; -- 1+1
UPDATE questions SET tags = ARRAY['text_analysis', 'character_counting'] WHERE id = 2; -- strawberry
UPDATE questions SET tags = ARRAY['text_analysis', 'character_counting'] WHERE id = 3; -- すもももも
```

### Phase 2: バックエンドモデル更新 🔧

#### 2-1. Question構造体にTagsフィールドを追加

```go
// backend/models/question.go
type Question struct {
    ID               int       `json:"id"`
    Level            int       `json:"level"`
    ProblemStatement string    `json:"problem_statement"`
    CorrectAnswer    string    `json:"correct_answer"`
    Tags             []string  `json:"tags"`                // 新規追加
    CreatedAt        time.Time `json:"created_at"`
}
```

#### 2-2. QuestionHandlerの更新

```go
// backend/handlers/question_handler.go
func (h *QuestionHandler) GetQuestions(c *gin.Context) {
    // SELECT文にtagsカラムを追加
    query := `
        SELECT id, level, problem_statement, correct_answer, tags, created_at
        FROM questions
        ORDER BY level ASC, id ASC
    `

    // Scanでtagsを取得
    // pq.Array を使用してPostgreSQLの配列をGoのスライスにマッピング
    err := rows.Scan(&q.ID, &q.Level, &q.ProblemStatement, &q.CorrectAnswer,
                     pq.Array(&q.Tags), &q.CreatedAt)
}
```

### Phase 3: タグメタデータの定義 📚

#### 3-1. タグマスターの作成

```go
// backend/models/tag.go
package models

type Tag struct {
    ID          string   `json:"id"`           // 内部識別子
    Label       string   `json:"label"`        // 表示名
    Icon        string   `json:"icon"`         // 絵文字アイコン
    Description string   `json:"description"`  // 説明
    PromptTips  []string `json:"prompt_tips"`  // プロンプトのコツ
    Color       string   `json:"color"`        // UIでの表示色
}

var TagDefinitions = map[string]Tag{
    "calculation": {
        ID:          "calculation",
        Label:       "計算問題",
        Icon:        "🧮",
        Description: "数値計算が必要な問題",
        PromptTips: []string{
            "「段階的に計算してください」と指示する",
            "「途中式を示してください」と依頼する",
            "計算順序を明確に指示する",
        },
        Color: "#3B82F6", // blue
    },
    "character_counting": {
        ID:          "character_counting",
        Label:       "文字数え",
        Icon:        "🔤",
        Description: "文字列内の特定文字を数える問題",
        PromptTips: []string{
            "「一文字ずつ確認してください」と指示する",
            "「リストアップしてください」と依頼する",
            "「見落としがないか確認してください」と念押しする",
        },
        Color: "#10B981", // green
    },
    "text_analysis": {
        ID:          "text_analysis",
        Label:       "文章解析",
        Icon:        "📝",
        Description: "文章を読み解いて答える問題",
        PromptTips: []string{
            "「問題文を整理してください」と指示する",
            "「条件を箇条書きにしてください」と依頼する",
            "「一つずつ確認してください」と指示する",
        },
        Color: "#F59E0B", // orange
    },
    // ... 他のタグも同様に定義
}
```

#### 3-2. タグ情報取得APIの作成

```go
// backend/handlers/tag_handler.go
type TagHandler struct{}

func NewTagHandler() *TagHandler {
    return &TagHandler{}
}

// GET /api/v1/tags - タグ一覧とメタデータを取得
func (h *TagHandler) GetTags(c *gin.Context) {
    c.JSON(http.StatusOK, gin.H{
        "tags": models.TagDefinitions,
    })
}

// GET /api/v1/tags/:tag_id - 特定タグの詳細を取得
func (h *TagHandler) GetTag(c *gin.Context) {
    tagID := c.Param("tag_id")
    tag, exists := models.TagDefinitions[tagID]

    if !exists {
        c.JSON(http.StatusNotFound, gin.H{
            "error": "tag_not_found",
            "message": "指定されたタグが見つかりません",
        })
        return
    }

    c.JSON(http.StatusOK, tag)
}
```

```go
// backend/routes/tag_routes.go
func RegisterTagRoutes(router *gin.RouterGroup, handler *TagHandler) {
    router.GET("/tags", handler.GetTags)
    router.GET("/tags/:tag_id", handler.GetTag)
}
```

### Phase 4: フロントエンド実装 🎨

#### 4-1. タグコンポーネントの作成

```tsx
// frontend/components/QuestionTag.tsx
interface QuestionTagProps {
  tag: string;
  size?: 'sm' | 'md' | 'lg';
  showTooltip?: boolean;
}

export const QuestionTag: React.FC<QuestionTagProps> = ({
  tag,
  size = 'md',
  showTooltip = true,
}) => {
  const tagInfo = TAG_DEFINITIONS[tag];

  if (!tagInfo) return null;

  return (
    <span
      className={`tag tag-${size}`}
      style={{ backgroundColor: tagInfo.color }}
      title={showTooltip ? tagInfo.description : undefined}
    >
      <span className="tag-icon">{tagInfo.icon}</span>
      <span className="tag-label">{tagInfo.label}</span>
    </span>
  );
};
```

#### 4-2. 問題一覧ページにタグを表示

```tsx
// frontend/src/app/questions/components/QuestionCard.tsx
export const QuestionCard: React.FC<QuestionCardProps> = ({ question }) => {
  return (
    <div className="question-card">
      <div className="question-header">
        <h3>問題 {question.id}</h3>
        <div className="question-tags">
          {question.tags.map((tag) => (
            <QuestionTag key={tag} tag={tag} size="sm" />
          ))}
        </div>
      </div>
      {/* ... 問題の内容 ... */}
    </div>
  );
};
```

#### 4-3. 問題詳細ページにプロンプトヒントを表示

```tsx
// frontend/src/app/questions/[id]/components/PromptHints.tsx
interface PromptHintsProps {
  tags: string[];
}

export const PromptHints: React.FC<PromptHintsProps> = ({ tags }) => {
  const allTips: string[] = [];

  tags.forEach((tag) => {
    const tagInfo = TAG_DEFINITIONS[tag];
    if (tagInfo?.promptTips) {
      allTips.push(...tagInfo.promptTips);
    }
  });

  if (allTips.length === 0) return null;

  return (
    <div className="prompt-hints">
      <h4>💡 プロンプトのコツ</h4>
      <ul>
        {allTips.map((tip, index) => (
          <li key={index}>{tip}</li>
        ))}
      </ul>
    </div>
  );
};
```

#### 4-4. タグ定義の型定義

```typescript
// frontend/types/tag.ts
export interface Tag {
  id: string;
  label: string;
  icon: string;
  description: string;
  prompt_tips: string[];
  color: string;
}

export const TAG_DEFINITIONS: Record<string, Tag> = {
  calculation: {
    id: 'calculation',
    label: '計算問題',
    icon: '🧮',
    description: '数値計算が必要な問題',
    prompt_tips: [
      '「段階的に計算してください」と指示する',
      '「途中式を示してください」と依頼する',
      '計算順序を明確に指示する',
    ],
    color: '#3B82F6',
  },
  // ... 他のタグも同様
};
```

### Phase 5: タグフィルタリング機能 🔍（推奨）

#### 5-1. タグによる問題絞り込み

```go
// backend/handlers/question_handler.go
// GET /api/v1/questions?tags=calculation,text_analysis
func (h *QuestionHandler) GetQuestions(c *gin.Context) {
    tagsParam := c.Query("tags")

    var query string
    var args []interface{}

    if tagsParam != "" {
        tags := strings.Split(tagsParam, ",")
        // タグの配列が指定されたタグのいずれかを含む問題を検索
        query = `
            SELECT id, level, problem_statement, correct_answer, tags, created_at
            FROM questions
            WHERE tags && $1
            ORDER BY level ASC, id ASC
        `
        args = append(args, pq.Array(tags))
    } else {
        query = `
            SELECT id, level, problem_statement, correct_answer, tags, created_at
            FROM questions
            ORDER BY level ASC, id ASC
        `
    }

    // ... クエリ実行
}
```

#### 5-2. フロントエンドのフィルターUI

```tsx
// frontend/src/app/questions/components/TagFilter.tsx
export const TagFilter: React.FC = () => {
  const [selectedTags, setSelectedTags] = useState<string[]>([]);

  const toggleTag = (tagId: string) => {
    setSelectedTags((prev) =>
      prev.includes(tagId) ? prev.filter((t) => t !== tagId) : [...prev, tagId],
    );
  };

  return (
    <div className="tag-filter">
      <h4>タグで絞り込み</h4>
      <div className="tag-list">
        {Object.values(TAG_DEFINITIONS).map((tag) => (
          <button
            key={tag.id}
            className={`tag-filter-button ${selectedTags.includes(tag.id) ? 'active' : ''}`}
            onClick={() => toggleTag(tag.id)}
          >
            <span>{tag.icon}</span>
            <span>{tag.label}</span>
          </button>
        ))}
      </div>
    </div>
  );
};
```

### Phase 6: タグ別統計表示 📊（推奨）

#### 6-1. タグ別スコア集計API

```go
// backend/handlers/stats_handler.go
type TagStats struct {
    Tag          string  `json:"tag"`
    Attempts     int     `json:"attempts"`
    AverageScore float64 `json:"average_score"`
    BestScore    int     `json:"best_score"`
}

// GET /api/v1/stats/by-tags?user_id=1
func (h *StatsHandler) GetStatsByTags(c *gin.Context) {
    userID := c.Query("user_id")

    query := `
        SELECT
            UNNEST(q.tags) as tag,
            COUNT(*) as attempts,
            AVG(s.score) as average_score,
            MAX(s.score) as best_score
        FROM scores s
        JOIN questions q ON s.question_id = q.id
        WHERE s.user_id = $1
        GROUP BY tag
        ORDER BY average_score DESC
    `

    // ... クエリ実行とJSON返却
}
```

#### 6-2. マイページでの統計表示

```tsx
// frontend/src/app/profile/components/TagStatsChart.tsx
export const TagStatsChart: React.FC<{ stats: TagStats[] }> = ({ stats }) => {
  return (
    <div className="tag-stats">
      <h3>タグ別成績</h3>
      <div className="stats-list">
        {stats.map((stat) => {
          const tagInfo = TAG_DEFINITIONS[stat.tag];
          return (
            <div key={stat.tag} className="stat-row">
              <span className="stat-tag">
                {tagInfo?.icon} {tagInfo?.label}
              </span>
              <div className="stat-values">
                <span>平均: {stat.average_score.toFixed(1)}点</span>
                <span>最高: {stat.best_score}点</span>
                <span>回答数: {stat.attempts}回</span>
              </div>
            </div>
          );
        })}
      </div>
    </div>
  );
};
```

## 依存関係 / リスク

- 依存: `questions` テーブルが存在すること。
- リスク: タグ数が増えすぎると UI が煩雑に → MVP では 3-5 タグに限定。
- リスク: タグ定義の一貫性 → `models/tag.go` で集中管理。

## 見積り / 担当 / 期日

- 見積り: 1.5人日（Phase 1-4 MVP部分）
- 担当: 未定
- 期日: Sprint2 前半 (2025-10-15 目安)

## UI/UX考慮事項

### タグ表示のベストプラクティス

1. **視認性**
   - 絵文字アイコンで直感的に理解できる
   - 色分けで素早く識別できる
   - 小さすぎず大きすぎない適切なサイズ

2. **情報の階層化**
   - 一覧ページ: タグアイコンと名前のみ（コンパクト）
   - 詳細ページ: タグ + プロンプトヒント（詳細）
   - ホバー時: タグの説明をツールチップで表示

3. **プロンプトヒントの提示方法**
   - 折りたたみ可能にして邪魔にならないようにする
   - 初回訪問時はデフォルトで開いておく
   - コピー機能を提供して簡単にプロンプトに貼り付けられる

4. **レスポンシブ対応**
   - モバイルでは1列表示
   - タブレット以上では2-3列表示
   - アイコンのみの表示モードも用意

## テストデータ例

### 初期問題データ（タグ付き）

```sql
INSERT INTO questions (level, problem_statement, correct_answer, tags) VALUES
(1, '1+1を計算してください。', '2', ARRAY['calculation']),
(2, '12 × 15 を計算してください。', '180', ARRAY['calculation']),
(3, 'strawberryの中にrは何個ある？', '3', ARRAY['character_counting', 'text_analysis']),
(4, '「すもももももももものうち」の中に「も」は何個ある？', '8', ARRAY['character_counting', 'text_analysis']),
(5, '太郎君は今年12歳です。お父さんは太郎君の3倍の年齢です。お父さんは何歳ですか？', '36', ARRAY['calculation', 'text_problem']),
(6, '1, 2, 4, 8, 16, ... 次に来る数は？', '32', ARRAY['pattern_recognition', 'calculation']);
```

## 参考リンク

- `../app.md`
- タスク#24: スコア調整の柔軟化 - タグに応じたスコアリングパラメータ設定
- タスク#23: 問題管理API実装 - 問題作成時のタグ設定機能

## 補足: Phase 5-6（推奨機能）

### Phase 5: タグフィルタリング

**目的:** ユーザーが興味のあるタイプの問題だけを絞り込める。

**実装:**

- バックエンド: `GET /api/v1/questions?tags=calculation,text_analysis`
- フロントエンド: タグボタンで ON/OFF 切替

**見積り:** 約3-4時間

### Phase 6: タグ別統計

**目的:** 得意/苦手なタイプを可視化。

**実装:**

- バックエンド: `GET /api/v1/stats/by-tags?user_id=1`
- フロントエンド: マイページでタグ別平均スコア表示

**見積り:** 約4-6時間

## 成功指標

1. **ユーザー理解度の向上**
   - 問題の性質を理解してからプロンプトを書くユーザーの割合
   - プロンプトヒントの参照率

2. **スコア改善**
   - タグ別ヒントを参照したユーザーの平均スコア向上率
   - 同じ問題への2回目以降の挑戦でのスコア改善率

3. **ユーザーエンゲージメント**
   - タグフィルター機能の使用率（Phase 5実装後）
   - タグ別統計ページの訪問率（Phase 6実装後）
